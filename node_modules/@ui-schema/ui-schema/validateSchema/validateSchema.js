"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateSchemaObject = exports.validateSchema = void 0;

var _TypeValidator = require("../Validators/TypeValidator/TypeValidator");

var _PatternValidator = require("../Validators/PatternValidator/PatternValidator");

var _MinMaxValidator = require("../Validators/MinMaxValidator/MinMaxValidator");

var _ValueValidator = require("../Validators/ValueValidator");

var _MultipleOfValidator = require("../Validators/MultipleOfValidator/MultipleOfValidator");

var _ArrayValidator = require("../Validators/ArrayValidator/ArrayValidator");

var _RequiredValidator = require("../Validators/RequiredValidator/RequiredValidator");

var _ObjectValidator = require("../Validators/ObjectValidator/ObjectValidator");

var _ValidatorErrors = require("@ui-schema/ui-schema/ValidatorErrors/ValidatorErrors");

var _OneOfValidator = require("@ui-schema/ui-schema/Validators/OneOfValidator");

/**
 * Return false when valid and string/List for an error
 *
 * @param schema
 * @param value
 * @return {ValidatorErrorsType}
 */
var validateSchema = function validateSchema(schema, value) {
  var type = schema.get('type');
  var pattern = schema.get('pattern');
  var err = (0, _ValidatorErrors.createValidatorErrors)();
  var not = schema.get('not');

  if (not) {
    // supporting `not` for any validations
    // https://json-schema.org/understanding-json-schema/reference/combining.html#not
    var tmpNot = validateSchema(not, value);
    return tmpNot.hasError() ? tmpNot.addError('not-is-valid') : err;
  }

  if (!(0, _TypeValidator.validateType)(value, type)) {
    err = err.addError(_TypeValidator.ERROR_WRONG_TYPE);
  } else if (!(0, _PatternValidator.validatePattern)(type, value, pattern)) {
    err = err.addError(_PatternValidator.ERROR_PATTERN);
  } else if (!(0, _ValueValidator.validateConst)(schema.get('const'), value)) {
    err = err.addError(_ValueValidator.ERROR_CONST_MISMATCH);
  } else if (!(0, _ValueValidator.validateEnum)(schema.get('enum'), value)) {
    err = err.addError(_ValueValidator.ERROR_ENUM_MISMATCH);
  } else if (!(0, _MultipleOfValidator.validateMultipleOf)(schema, value)) {
    err = err.addError(_MultipleOfValidator.ERROR_MULTIPLE_OF);
  } else {
    var errMinMax = (0, _MinMaxValidator.validateMinMax)(schema, value);

    if (errMinMax.hasError()) {
      return errMinMax;
    }

    var errObj = (0, _ObjectValidator.validateObject)(schema, value);

    if (errObj.hasError()) {
      return errObj;
    }

    var errContains = (0, _ArrayValidator.validateContains)(schema, value);

    if (errContains.hasError()) {
      return errContains;
    }

    var errOneOf = (0, _OneOfValidator.validateOneOf)(schema.get('oneOf'), value);

    if (errOneOf.errors.hasError()) {
      return errOneOf.errors;
    }
  }

  return err;
};
/**
 * Validating the value, property for property.
 *
 * @param {Map} schema
 * @param {Map|Record} value
 * @return {List<*>}
 */


exports.validateSchema = validateSchema;

var validateSchemaObject = function validateSchemaObject(schema, value) {
  var err = (0, _ValidatorErrors.createValidatorErrors)();
  var properties = schema.get('properties');
  if (!properties) return err;
  properties.forEach(function (subSchema, key) {
    var val = value.get(key);

    if (typeof val === 'undefined') {
      err = err.addError(_RequiredValidator.ERROR_NOT_SET);
      return;
    }

    var t = validateSchema(subSchema, val);

    if (t.hasError()) {
      err = err.addErrors(t);
    }
  });
  return err;
};

exports.validateSchemaObject = validateSchemaObject;