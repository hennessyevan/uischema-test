import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
const _excluded = ["widgets"],
      _excluded2 = ["currentPluginIndex"];
import React from 'react';
import { List } from 'immutable';
import { memo } from '@ui-schema/ui-schema/Utils/memo';
import { useUIMeta } from '@ui-schema/ui-schema/UIMeta';
import { createValidatorErrors } from '@ui-schema/ui-schema/ValidatorErrors';
import { useUIConfig } from '@ui-schema/ui-schema/UIStore';
import { useImmutable } from '@ui-schema/ui-schema/Utils/useImmutable';
import { PluginStackErrorBoundary } from '@ui-schema/ui-schema/PluginStack'; // `extractValue` has moved to own plugin `ExtractStorePlugin` since `0.3.0`
// `withUIMeta` and `mema` are not needed for performance optimizing since `0.3.0` at this position

export const PluginStack = props => {
  const _useUIMeta = useUIMeta(),
        {
    widgets
  } = _useUIMeta,
        meta = _objectWithoutProperties(_useUIMeta, _excluded);

  const config = useUIConfig();
  const {
    level = 0,
    parentSchema,
    storeKeys,
    schema,
    widgets: customWidgets
  } = props; // central reference integrity of `storeKeys` for all plugins and the receiving widget, otherwise `useImmutable` is needed more times, e.g. 3 times in plugins + 1x time in widget

  const currentStoreKeys = useImmutable(storeKeys);
  const activeWidgets = customWidgets || widgets;
  const isVirtual = Boolean(props.isVirtual || (schema === null || schema === void 0 ? void 0 : schema.get('hidden')));
  let required = List([]);

  if (parentSchema) {
    // todo: resolving `required` here is wrong, must be done after merging schema / resolving referenced
    //      ! actual, it is correct here, as using `parentSchema`
    let tmp_required = parentSchema.get('required');

    if (tmp_required) {
      required = tmp_required;
    }
  }

  const ErrorBoundary = activeWidgets !== null && activeWidgets !== void 0 && activeWidgets.ErrorFallback ? PluginStackErrorBoundary : React.Fragment;
  return props.schema ? /*#__PURE__*/React.createElement(ErrorBoundary, {
    FallbackComponent: activeWidgets === null || activeWidgets === void 0 ? void 0 : activeWidgets.ErrorFallback,
    type: schema.get('type'),
    widget: schema.get('widget'),
    storeKeys: currentStoreKeys
  }, /*#__PURE__*/React.createElement(NextPluginRenderer, _extends({}, meta, config, props, {
    currentPluginIndex: -1,
    widgets: activeWidgets,
    level: level,
    storeKeys: currentStoreKeys,
    ownKey: storeKeys.get(storeKeys.count() - 1),
    requiredList: required,
    required: false,
    errors: createValidatorErrors(),
    isVirtual: isVirtual,
    valid: true
  }))) : null;
};
export const getNextPlugin = (next, {
  pluginStack: ps,
  WidgetRenderer
}) => next < ps.length ? ps[next] || (() => 'plugin-error') : WidgetRenderer;
export const NextPluginRenderer = _ref => {
  let {
    currentPluginIndex
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded2);

  const next = currentPluginIndex + 1;
  const Plugin = getNextPlugin(next, props.widgets);
  return /*#__PURE__*/React.createElement(Plugin, _extends({}, props, {
    currentPluginIndex: next
  }));
};
export const NextPluginRendererMemo = memo(NextPluginRenderer);