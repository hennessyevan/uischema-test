import { OrderedMap, List, Map } from 'immutable';
import { validateMinMax, minMaxValidator, ERROR_MAX_LENGTH, ERROR_MIN_LENGTH } from '@ui-schema/ui-schema/Validators/MinMaxValidator';
import { createMap, createOrderedMap } from '@ui-schema/ui-schema/Utils';
import { createValidatorErrors } from '@ui-schema/ui-schema/ValidatorErrors/ValidatorErrors';
describe('validateMinMax', () => {
  const validateMinMaxTestValues = [[{
    type: 'string',
    minLength: 2
  }, 'te', 0], [{
    type: 'string',
    minLength: 2
  }, 't', 1], [{
    type: 'string',
    minLength: 1
  }, '', 1], [{
    type: 'string',
    maxLength: 2
  }, 'tex', 1], [{
    type: 'string',
    maxLength: 2
  }, 'te', 0], [{
    type: 'string',
    maxLength: 2
  }, 111, 0], [{
    type: ['string'],
    maxLength: 2
  }, 'tex', 1], [{
    type: ['string'],
    maxLength: 2
  }, 'te', 0], [{
    type: ['string'],
    maxLength: 2
  }, 111, 0], [{
    type: ['string', 'number'],
    maxLength: 2
  }, 'tex', // todo: add test for "is-correct-error"
  1], [{
    type: ['string', 'number'],
    maxLength: 2
  }, 'te', 0], [{
    type: ['string', 'number'],
    maxLength: 2
  }, 111, 0], [{
    type: ['string', 'array'],
    maxLength: 2,
    minItems: 2
  }, // todo: add test for "is-correct-error"
  ['text1'], 1], [{
    type: ['string', 'array'],
    maxLength: 2,
    minItems: 2
  }, // todo: add test for "is-correct-error"
  'tex', 1], [{
    type: ['string', 'array'],
    maxLength: 2,
    minItems: 2
  }, // todo: add test for "is-correct-error"
  ['text1', 'text2'], 0], [{
    type: ['string', 'array'],
    maxLength: 2,
    minItems: 2
  }, 'te', 0], [{
    type: 'array',
    minItems: 2
  }, ['text1'], 1], [{
    type: 'array',
    minItems: 2
  }, ['text1', 'text2'], 0], [{
    type: 'array',
    minItems: 2
  }, 'not-an-array', 0], [{
    type: 'array',
    maxItems: 2
  }, 'not-an-array', 0], [{
    type: 'array',
    maxItems: 2
  }, ['text1', 'text2'], 0], [{
    type: 'array',
    maxItems: 2
  }, ['text1', 'text2', 'text3'], 1], [{
    type: 'array',
    minItems: 2
  }, List(['text1']), 1], [{
    type: 'array',
    minItems: 2
  }, List(['text1', 'text2']), 0], [{
    type: 'array',
    maxItems: 2
  }, List(['text1', 'text2']), 0], [{
    type: 'array',
    maxItems: 2
  }, List(['text1', 'text2', 'text3']), 1], [{
    type: 'object',
    minProperties: 2
  }, {
    a: 'text1'
  }, 1], [{
    type: 'object',
    minProperties: 2
  }, {
    a: 'text1',
    b: 'text2'
  }, 0], [{
    type: 'object',
    minProperties: 2
  }, 'not-an-object', 0], [{
    type: 'object',
    maxProperties: 2
  }, 'not-an-object', 0], [{
    type: 'object',
    maxProperties: 2
  }, {
    a: 'text1',
    b: 'text2'
  }, 0], [{
    type: 'object',
    maxProperties: 2
  }, {
    a: 'text1',
    b: 'text2',
    c: 'text3'
  }, 1], [{
    type: 'object',
    minProperties: 2
  }, createMap({
    a: 'text1'
  }), 1], [{
    type: 'object',
    minProperties: 2
  }, createMap({
    a: 'text1',
    b: 'text2'
  }), 0], [{
    type: 'object',
    maxProperties: 2
  }, createMap({
    a: 'text1',
    b: 'text2'
  }), 0], [{
    type: 'object',
    maxProperties: 2
  }, createMap({
    a: 'text1',
    b: 'text2',
    c: 'text3'
  }), 1], [{
    type: 'number',
    minimum: 2
  }, 1, 1], [{
    type: 'number',
    minimum: 2
  }, 2, 0], [{
    type: 'number',
    maximum: 2
  }, 2, 0], [{
    type: 'number',
    maximum: 2
  }, 3, 1], [{
    type: 'number',
    exclusiveMinimum: 2
  }, 2, 1], [{
    type: 'number',
    exclusiveMinimum: 2
  }, 3, 0], [{
    type: 'number',
    exclusiveMaximum: 2
  }, 1, 0], [{
    type: 'number',
    exclusiveMaximum: 2
  }, 2, 1], [{
    type: 'integer',
    minimum: 2
  }, 1, 1], [{
    type: 'integer',
    minimum: 2
  }, 2, 0], [{
    type: 'integer',
    maximum: 2
  }, 2, 0], [{
    type: 'integer',
    maximum: 2
  }, 3, 1], [{
    type: 'integer',
    exclusiveMinimum: 2
  }, 2, 1], [{
    type: 'integer',
    exclusiveMinimum: 2
  }, 3, 0], [{
    type: 'integer',
    exclusiveMaximum: 2
  }, 1, 0], [{
    type: 'integer',
    exclusiveMaximum: 2
  }, 2, 1], [// @ts-ignore draft-04 check
  {
    type: 'integer',
    exclusiveMinimum: true,
    minimum: 2
  }, 2, 1], [// @ts-ignore draft-04 check
  {
    type: 'integer',
    exclusiveMinimum: true,
    minimum: 2
  }, 3, 0], [// @ts-ignore draft-04 check
  {
    type: 'integer',
    exclusiveMaximum: true,
    maximum: 2
  }, 1, 0], [// @ts-ignore draft-04 check
  {
    type: 'integer',
    exclusiveMaximum: true,
    maximum: 2
  }, 2, 1], [{
    type: 'integer',
    maximum: 2
  }, undefined, 0], [{
    type: ['integer'],
    maximum: 2
  }, undefined, 0], [{
    type: ['integer', 'string'],
    maximum: 2
  }, undefined, 0]];
  test.each(validateMinMaxTestValues)('validateMinMax(%j, %j)', (schema, value, expected) => {
    const orderedSchema = createOrderedMap(schema);
    expect(validateMinMax(orderedSchema, value).errCount).toBe(expected);
  });
});
describe('minMaxValidator', () => {
  const minMaxValidatorTestValues = [[{
    type: 'string',
    maxLength: 2
  }, 'tt', List([ERROR_MAX_LENGTH, Map({
    max: 2
  })]), true, false], [{
    type: 'string',
    maxLength: 2
  }, 'ttt', List([ERROR_MAX_LENGTH, Map({
    max: 2
  })]), false, true], [{
    type: 'string',
    minLength: 2
  }, 'tt', List([ERROR_MIN_LENGTH, Map({
    min: 2
  })]), true, false], [{
    type: 'string',
    minLength: 2
  }, 't', List([ERROR_MIN_LENGTH, Map({
    min: 2
  })]), false, true]];
  test.each(minMaxValidatorTestValues)('.handle(%j, %s)', (schema, value, error, expectedValid, expectedError) => {
    const result = minMaxValidator.handle({
      schema: OrderedMap(schema),
      // @ts-ignore
      value,
      errors: createValidatorErrors(),
      valid: true
    });
    expect(result.valid).toBe(expectedValid);
    expect(result.errors.hasError(error.get(0))).toBe(expectedError);

    if (result.errors.hasError(error.get(0))) {
      var _result$errors$getErr;

      expect((_result$errors$getErr = result.errors.getError(error.get(0)).get(0)) === null || _result$errors$getErr === void 0 ? void 0 : _result$errors$getErr.equals(error.get(1))).toBe(expectedError);
    }
  });
});