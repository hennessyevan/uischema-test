import { handleIfElseThen } from '@ui-schema/ui-schema/Plugins/ConditionalHandler';
import { mergeSchema } from '@ui-schema/ui-schema/Utils/mergeSchema';
import { Record, Map } from 'immutable';
import React from 'react';
export const handleSchemaCombine = (schema, value) => {
  const allOf = schema.get('allOf');

  if (allOf) {
    allOf.forEach(subSchema => {
      // removing afterwards-handled keywords, otherwise they would merge wrongly/double evaluate
      schema = mergeSchema(schema, subSchema.delete('if').delete('else').delete('then').delete('allOf'));

      if (value && (Map.isMap(value) || Record.isRecord(value))) {
        schema = handleIfElseThen(subSchema, value, schema);
      }

      const allOf1 = subSchema.get('allOf');

      if (allOf1) {
        // nested allOf may appear when using complex combining-conditional schemas
        allOf1.forEach(subSchema1 => {
          // removing afterwards-handled keywords, otherwise they would merge wrongly/double evaluate
          // further on nested `allOf` will be resolved by render flow
          schema = mergeSchema(schema, subSchema1.delete('if').delete('else').delete('then'));

          if (value && (Map.isMap(value) || Record.isRecord(value))) {
            schema = handleIfElseThen(subSchema1, value, schema);
          }
        });
      }
    });
  }

  return schema;
};
export const useSchemaCombine = (schema, value) => {
  return React.useMemo(() => handleSchemaCombine(schema, value), [schema, value]);
};