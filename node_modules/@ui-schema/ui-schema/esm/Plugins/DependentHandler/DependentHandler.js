import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
const _excluded = ["dependencies", "dependentSchemas", "dependentRequired"];
import React from 'react';
import { getNextPlugin, NextPluginRendererMemo } from '@ui-schema/ui-schema/PluginStack';
import { useUIStore } from '@ui-schema/ui-schema/UIStore';
import { mergeSchema } from '@ui-schema/ui-schema/Utils/mergeSchema';
import { List, Map } from 'immutable';

const DependentRenderer = _ref => {
  let {
    dependencies,
    dependentSchemas,
    dependentRequired
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded);

  let {
    schema,
    storeKeys
  } = props;
  const {
    store
  } = useUIStore();
  const currentValues = storeKeys.size ? store.getValues().getIn(storeKeys) : store.getValues();
  if (!currentValues) return /*#__PURE__*/React.createElement(NextPluginRendererMemo, _extends({}, props, {
    schema: schema
  }));
  currentValues.keySeq().forEach(key => {
    const key_dependencies = dependencies ? dependencies.get(key) : undefined;
    const key_dependentSchemas = dependentSchemas ? dependentSchemas.get(key) : undefined;
    const key_dependentRequired = dependentRequired ? dependentRequired.get(key) : undefined; // todo: what if the `key`'s own schema should be dynamically changed?
    //   what to remove?
    //   what to keep? when keeping e.g. `const` it could destroy `enum`s
    // "if property is present", must not use "if correct type"

    if (typeof currentValues.get(key) !== 'undefined') {
      if (Map.isMap(key_dependencies) || Map.isMap(key_dependentSchemas)) {
        // schema-dependencies
        // value for dependency exist, so it should be used
        if (Map.isMap(key_dependencies)) {
          schema = mergeSchema(schema, key_dependencies);
        } else {
          schema = mergeSchema(schema, key_dependentSchemas);
        }
      }

      if (List.isList(key_dependencies) || List.isList(key_dependentRequired)) {
        // property-dependencies
        // value for dependency exist, so it should be used
        const currentRequired = schema.get('required') || List();

        if (List.isList(key_dependencies)) {
          schema = schema.set('required', currentRequired.concat(key_dependencies));
        } else {
          schema = schema.set('required', currentRequired.concat(key_dependentRequired));
        }
      }
    }
  });
  return /*#__PURE__*/React.createElement(NextPluginRendererMemo, _extends({}, props, {
    schema: schema
  }));
};

export const DependentHandler = props => {
  let {
    storeKeys,
    ownKey,
    schema,
    currentPluginIndex
  } = props;
  const next = currentPluginIndex + 1;
  const Plugin = getNextPlugin(next, props.widgets);
  const dependencies = schema.get('dependencies');
  const dependentSchemas = schema.get('dependentSchemas');
  const dependentRequired = schema.get('dependentRequired');
  return /*#__PURE__*/React.createElement(React.Fragment, null, dependencies || dependentSchemas || dependentRequired ? /*#__PURE__*/React.createElement(DependentRenderer, _extends({
    dependencies: dependencies,
    dependentSchemas: dependentSchemas,
    dependentRequired: dependentRequired,
    storeKeys: storeKeys,
    ownKey: ownKey
  }, props)) : /*#__PURE__*/React.createElement(Plugin, _extends({}, props, {
    currentPluginIndex: next
  })));
};