import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * @jest-environment jsdom
 */
import { test, expect, describe } from '@jest/globals';
import { toBeInTheDocument, toHaveClass // @ts-ignore
} from '@testing-library/jest-dom/matchers';
import { List, Map, OrderedMap } from 'immutable';
import { UIStore } from '@ui-schema/ui-schema/UIStore';
import { storeUpdater } from '@ui-schema/ui-schema';
expect.extend({
  toBeInTheDocument,
  toHaveClass
});
/**
 * npm run tdd -- -u --testPathPattern=src/storeUpdater/storeUpdater.test.ts
 */

describe('storeUpdater', () => {
  test.each([[new UIStore({
    values: OrderedMap({})
  }), List([]), ['value'], ({
    value
  }) => ({
    value
  }), undefined, undefined, new UIStore({
    values: OrderedMap({})
  })], [new UIStore({
    values: OrderedMap({
      prop_a: 'some-string'
    })
  }), List(['prop_a']), ['value'], ({
    value
  }) => ({
    value: value + '--modified'
  }), undefined, undefined, new UIStore({
    values: OrderedMap({
      prop_a: 'some-string--modified'
    })
  })], [new UIStore({
    // initial store
    values: OrderedMap({
      prop_a: 'some-string'
    })
  }), List(['prop_a']), // storeKeys
  ['value'], // scopes
  () => ({
    value: ''
  }), true, // deleteOnEmpty
  'string', // type
  new UIStore({
    // expected
    values: OrderedMap({})
  })], [new UIStore({
    // initial store
    values: OrderedMap({
      prop_a: 'some-string'
    }),
    internals: Map({})
  }), List(['prop_a']), // storeKeys
  ['value', 'internal', 'valid'], // scopes
  ({
    value,
    internal = Map({})
  }) => ({
    value: value + '--modified',
    internal: internal.set('value', 'some-state'),
    valid: true
  }), undefined, // deleteOnEmpty
  undefined, // type
  new UIStore({
    // expected
    values: OrderedMap({
      prop_a: 'some-string--modified'
    }),
    internals: Map({
      internals: Map({
        prop_a: Map({
          value: 'some-state'
        })
      })
    }),
    validity: Map({
      prop_a: Map({
        __valid: true
      })
    })
  })]])('storeUpdater %j, %j', (store, storeKeys, scopes, updater, deleteOnEmpty, type, expected) => {
    const action = _objectSpread(_objectSpread({
      type: 'update',
      storeKeys,
      scopes,
      updater: updater
    }, type ? {
      schema: Map({
        type
      })
    } : {}), deleteOnEmpty ? {
      required: true
    } : {});

    const r = storeUpdater(action)(store);
    const isExpected = r.equals(expected);

    if (!isExpected) {
      console.log('failed storeUpdater', storeKeys.toJS(), scopes, JSON.stringify(store.toJS(), undefined, 2), JSON.stringify(r === null || r === void 0 ? void 0 : r.toJS(), undefined, 2), JSON.stringify(expected === null || expected === void 0 ? void 0 : expected.toJS(), undefined, 2));
    }

    expect(isExpected).toBe(true);
  });
});