"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldDeleteOnEmpty = exports.prependKey = exports.createStore = exports.createEmptyStore = exports.addNestKey = exports.UIStore = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _immutable = require("immutable");

var _schemaTypeIs = require("@ui-schema/ui-schema/Utils/schemaTypeIs");

var _UIStore = require("@ui-schema/ui-schema/UIStore");

// only to enable better minification, DO NOT EXPORT
var STR_INTERNALS = 'internals';
var STR_VALUES = 'values';
var STR_VALIDITY = 'validity';
var UIStore = (0, _immutable.Record)({
  values: undefined,
  // internals must be an map when it is an object in the root, for array a List and for other "any type"
  internals: (0, _immutable.Map)(),
  validity: (0, _immutable.Map)(),
  meta: (0, _immutable.Map)(),
  valuesToJS: function valuesToJS() {
    var values = this.get(STR_VALUES);
    if (_immutable.Map.isMap(values) || _immutable.List.isList(values) || _immutable.Record.isRecord(values)) return values.toJS();
    return values;
  },
  getValues: function getValues() {
    return this.get(STR_VALUES);
  },
  getInternals: function getInternals() {
    return this.get(STR_INTERNALS);
  },
  getValidity: function getValidity() {
    return this.get(STR_VALIDITY);
  },
  extractValues: function extractValues(storeKeys) {
    return (0, _UIStore.doExtractValues)(storeKeys, this);
  }
});
exports.UIStore = UIStore;

var createStore = function createStore(values) {
  return new UIStore({
    values: values,
    internals: (0, _immutable.Map)({
      internals: _immutable.List.isList(values) ? (0, _immutable.List)() : (0, _immutable.Map)()
    }),
    validity: (0, _immutable.Map)(),
    meta: (0, _immutable.Map)()
  });
}; // todo: support multiple types #68


exports.createStore = createStore;

var createEmptyStore = function createEmptyStore() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'object';
  return createStore(type === 'array' ? (0, _immutable.List)([]) : type === 'string' ? '' : type === 'number' || type === 'integer' ? 0 : type === 'boolean' ? false : (0, _immutable.Map)());
};

exports.createEmptyStore = createEmptyStore;

var prependKey = function prependKey(storeKeys, key) {
  return Array.isArray(storeKeys) ? [key].concat((0, _toConsumableArray2["default"])(storeKeys)) : storeKeys.splice(0, 0, key);
};

exports.prependKey = prependKey;

var shouldDeleteOnEmpty = function shouldDeleteOnEmpty(value, force, type) {
  var valueTypeOf = (0, _typeof2["default"])(value); // todo: mv number out here, enforces that numbers can be cleared, but should only be forced for the `""` value in number types

  if (!force && !(0, _schemaTypeIs.schemaTypeIsNumeric)(type)) return false;
  if (valueTypeOf === 'undefined') return true;

  if ((0, _schemaTypeIs.schemaTypeIs)(type, 'string') && valueTypeOf === 'string' || (0, _schemaTypeIs.schemaTypeIs)(type, 'number') && (valueTypeOf === 'number' || valueTypeOf === 'string') || (0, _schemaTypeIs.schemaTypeIs)(type, 'integer') && (valueTypeOf === 'number' || valueTypeOf === 'string')) {
    return value === '' || valueTypeOf === 'undefined' || valueTypeOf === 'string' && 0 === value.trim().length;
  } else if ((0, _schemaTypeIs.schemaTypeIs)(type, 'boolean') && valueTypeOf === 'boolean') {
    return !value;
  } else if ((0, _schemaTypeIs.schemaTypeIs)(type, 'array') && (_immutable.List.isList(value) || Array.isArray(value))) {
    return _immutable.List.isList(value) && value.size === 0 || Array.isArray(value) && value.length === 0;
  } else if ((0, _schemaTypeIs.schemaTypeIs)(type, 'object') && (_immutable.Map.isMap(value) || _immutable.Record.isRecord(value) || valueTypeOf === 'object')) {
    return (_immutable.Map.isMap(value) || _immutable.Record.isRecord(value)) && value.keySeq().size === 0 || valueTypeOf === 'object' && Object.keys(value).length === 0;
  }

  return false;
};

exports.shouldDeleteOnEmpty = shouldDeleteOnEmpty;

var addNestKey = function addNestKey(storeKeysNestedKey, storeKeys) {
  return storeKeysNestedKey ? storeKeys.reduce(function (nk, sk) {
    return nk === null || nk === void 0 ? void 0 : nk.concat(sk, (0, _immutable.List)([storeKeysNestedKey]));
  }, (0, _immutable.List)([storeKeysNestedKey])).splice(-1, 1) : storeKeys;
};

exports.addNestKey = addNestKey;