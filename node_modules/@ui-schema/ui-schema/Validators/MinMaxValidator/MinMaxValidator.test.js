"use strict";

var _immutable = require("immutable");

var _MinMaxValidator = require("@ui-schema/ui-schema/Validators/MinMaxValidator");

var _Utils = require("@ui-schema/ui-schema/Utils");

var _ValidatorErrors = require("@ui-schema/ui-schema/ValidatorErrors/ValidatorErrors");

describe('validateMinMax', function () {
  var validateMinMaxTestValues = [[{
    type: 'string',
    minLength: 2
  }, 'te', 0], [{
    type: 'string',
    minLength: 2
  }, 't', 1], [{
    type: 'string',
    minLength: 1
  }, '', 1], [{
    type: 'string',
    maxLength: 2
  }, 'tex', 1], [{
    type: 'string',
    maxLength: 2
  }, 'te', 0], [{
    type: 'string',
    maxLength: 2
  }, 111, 0], [{
    type: ['string'],
    maxLength: 2
  }, 'tex', 1], [{
    type: ['string'],
    maxLength: 2
  }, 'te', 0], [{
    type: ['string'],
    maxLength: 2
  }, 111, 0], [{
    type: ['string', 'number'],
    maxLength: 2
  }, 'tex', // todo: add test for "is-correct-error"
  1], [{
    type: ['string', 'number'],
    maxLength: 2
  }, 'te', 0], [{
    type: ['string', 'number'],
    maxLength: 2
  }, 111, 0], [{
    type: ['string', 'array'],
    maxLength: 2,
    minItems: 2
  }, // todo: add test for "is-correct-error"
  ['text1'], 1], [{
    type: ['string', 'array'],
    maxLength: 2,
    minItems: 2
  }, // todo: add test for "is-correct-error"
  'tex', 1], [{
    type: ['string', 'array'],
    maxLength: 2,
    minItems: 2
  }, // todo: add test for "is-correct-error"
  ['text1', 'text2'], 0], [{
    type: ['string', 'array'],
    maxLength: 2,
    minItems: 2
  }, 'te', 0], [{
    type: 'array',
    minItems: 2
  }, ['text1'], 1], [{
    type: 'array',
    minItems: 2
  }, ['text1', 'text2'], 0], [{
    type: 'array',
    minItems: 2
  }, 'not-an-array', 0], [{
    type: 'array',
    maxItems: 2
  }, 'not-an-array', 0], [{
    type: 'array',
    maxItems: 2
  }, ['text1', 'text2'], 0], [{
    type: 'array',
    maxItems: 2
  }, ['text1', 'text2', 'text3'], 1], [{
    type: 'array',
    minItems: 2
  }, (0, _immutable.List)(['text1']), 1], [{
    type: 'array',
    minItems: 2
  }, (0, _immutable.List)(['text1', 'text2']), 0], [{
    type: 'array',
    maxItems: 2
  }, (0, _immutable.List)(['text1', 'text2']), 0], [{
    type: 'array',
    maxItems: 2
  }, (0, _immutable.List)(['text1', 'text2', 'text3']), 1], [{
    type: 'object',
    minProperties: 2
  }, {
    a: 'text1'
  }, 1], [{
    type: 'object',
    minProperties: 2
  }, {
    a: 'text1',
    b: 'text2'
  }, 0], [{
    type: 'object',
    minProperties: 2
  }, 'not-an-object', 0], [{
    type: 'object',
    maxProperties: 2
  }, 'not-an-object', 0], [{
    type: 'object',
    maxProperties: 2
  }, {
    a: 'text1',
    b: 'text2'
  }, 0], [{
    type: 'object',
    maxProperties: 2
  }, {
    a: 'text1',
    b: 'text2',
    c: 'text3'
  }, 1], [{
    type: 'object',
    minProperties: 2
  }, (0, _Utils.createMap)({
    a: 'text1'
  }), 1], [{
    type: 'object',
    minProperties: 2
  }, (0, _Utils.createMap)({
    a: 'text1',
    b: 'text2'
  }), 0], [{
    type: 'object',
    maxProperties: 2
  }, (0, _Utils.createMap)({
    a: 'text1',
    b: 'text2'
  }), 0], [{
    type: 'object',
    maxProperties: 2
  }, (0, _Utils.createMap)({
    a: 'text1',
    b: 'text2',
    c: 'text3'
  }), 1], [{
    type: 'number',
    minimum: 2
  }, 1, 1], [{
    type: 'number',
    minimum: 2
  }, 2, 0], [{
    type: 'number',
    maximum: 2
  }, 2, 0], [{
    type: 'number',
    maximum: 2
  }, 3, 1], [{
    type: 'number',
    exclusiveMinimum: 2
  }, 2, 1], [{
    type: 'number',
    exclusiveMinimum: 2
  }, 3, 0], [{
    type: 'number',
    exclusiveMaximum: 2
  }, 1, 0], [{
    type: 'number',
    exclusiveMaximum: 2
  }, 2, 1], [{
    type: 'integer',
    minimum: 2
  }, 1, 1], [{
    type: 'integer',
    minimum: 2
  }, 2, 0], [{
    type: 'integer',
    maximum: 2
  }, 2, 0], [{
    type: 'integer',
    maximum: 2
  }, 3, 1], [{
    type: 'integer',
    exclusiveMinimum: 2
  }, 2, 1], [{
    type: 'integer',
    exclusiveMinimum: 2
  }, 3, 0], [{
    type: 'integer',
    exclusiveMaximum: 2
  }, 1, 0], [{
    type: 'integer',
    exclusiveMaximum: 2
  }, 2, 1], [// @ts-ignore draft-04 check
  {
    type: 'integer',
    exclusiveMinimum: true,
    minimum: 2
  }, 2, 1], [// @ts-ignore draft-04 check
  {
    type: 'integer',
    exclusiveMinimum: true,
    minimum: 2
  }, 3, 0], [// @ts-ignore draft-04 check
  {
    type: 'integer',
    exclusiveMaximum: true,
    maximum: 2
  }, 1, 0], [// @ts-ignore draft-04 check
  {
    type: 'integer',
    exclusiveMaximum: true,
    maximum: 2
  }, 2, 1], [{
    type: 'integer',
    maximum: 2
  }, undefined, 0], [{
    type: ['integer'],
    maximum: 2
  }, undefined, 0], [{
    type: ['integer', 'string'],
    maximum: 2
  }, undefined, 0]];
  test.each(validateMinMaxTestValues)('validateMinMax(%j, %j)', function (schema, value, expected) {
    var orderedSchema = (0, _Utils.createOrderedMap)(schema);
    expect((0, _MinMaxValidator.validateMinMax)(orderedSchema, value).errCount).toBe(expected);
  });
});
describe('minMaxValidator', function () {
  var minMaxValidatorTestValues = [[{
    type: 'string',
    maxLength: 2
  }, 'tt', (0, _immutable.List)([_MinMaxValidator.ERROR_MAX_LENGTH, (0, _immutable.Map)({
    max: 2
  })]), true, false], [{
    type: 'string',
    maxLength: 2
  }, 'ttt', (0, _immutable.List)([_MinMaxValidator.ERROR_MAX_LENGTH, (0, _immutable.Map)({
    max: 2
  })]), false, true], [{
    type: 'string',
    minLength: 2
  }, 'tt', (0, _immutable.List)([_MinMaxValidator.ERROR_MIN_LENGTH, (0, _immutable.Map)({
    min: 2
  })]), true, false], [{
    type: 'string',
    minLength: 2
  }, 't', (0, _immutable.List)([_MinMaxValidator.ERROR_MIN_LENGTH, (0, _immutable.Map)({
    min: 2
  })]), false, true]];
  test.each(minMaxValidatorTestValues)('.handle(%j, %s)', function (schema, value, error, expectedValid, expectedError) {
    var result = _MinMaxValidator.minMaxValidator.handle({
      schema: (0, _immutable.OrderedMap)(schema),
      // @ts-ignore
      value: value,
      errors: (0, _ValidatorErrors.createValidatorErrors)(),
      valid: true
    });

    expect(result.valid).toBe(expectedValid);
    expect(result.errors.hasError(error.get(0))).toBe(expectedError);

    if (result.errors.hasError(error.get(0))) {
      var _result$errors$getErr;

      expect((_result$errors$getErr = result.errors.getError(error.get(0)).get(0)) === null || _result$errors$getErr === void 0 ? void 0 : _result$errors$getErr.equals(error.get(1))).toBe(expectedError);
    }
  });
});