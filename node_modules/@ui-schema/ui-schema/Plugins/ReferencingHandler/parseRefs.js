"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseRefs = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _immutable = require("immutable");

var _resolveRef = require("@ui-schema/ui-schema/Plugins/ReferencingHandler/resolveRef");

var _SchemaRootProvider = require("@ui-schema/ui-schema/SchemaRootProvider");

var _getSchema = require("@ui-schema/ui-schema/Utils/getSchema");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var handleResolve = function handleResolve(keywords, condition, schema, context, recursive, pending) {
  Object.keys(keywords).forEach(function (keyword) {
    // schemaMap can be a `Map` or a `List`
    var schemaMap = schema.get(keyword);

    if (schemaMap && condition(schemaMap)) {
      schema = schema.set(keyword, schemaMap.map(function (subSchema) {
        var res = parseRefs(subSchema, context, keywords[keyword] || recursive, pending);
        pending = res.pending;
        return res.schema;
      }));
    }
  });
  return {
    schema: schema,
    pending: pending
  };
}; // all keywords which nested schemas in maps


var checkNestedMapSchema = {
  properties: false
}; // all keywords which are an array of schemas

var checkNestedArraySchema = {};

var parseRefsInRenderingKeywords = function parseRefsInRenderingKeywords(schema, context, recursive) {
  var pending = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : (0, _immutable.Map)();
  // for all schema keywords which will be rendered, only the root references must be resolved,
  // but not if they are within an e.g. `if`
  // - e.g. references within `properties` doesn't need to be resolved before they are rendered
  var res = {
    schema: schema,
    pending: pending
  };
  res = handleResolve(checkNestedMapSchema, function (schemaMap) {
    return _immutable.Map.isMap(schemaMap);
  }, res.schema, context, recursive, res.pending);
  res = handleResolve(checkNestedArraySchema, function (schemaList) {
    return _immutable.List.isList(schemaList);
  }, res.schema, context, recursive, res.pending);
  return res;
}; // conditional keywords who must resolve recursive


var checkConditionalNestedMapSchema = {
  patternProperties: true,
  dependencies: false,
  dependentSchemas: false
}; // all keywords which are an array of schemas

var checkConditionalNestedArraySchema = {
  allOf: false,
  oneOf: false,
  anyOf: false,
  // here items are tuple-schema arrays
  items: false
};
var checkSchema = {
  "if": true,
  "else": false,
  then: false,
  not: false,
  propertyNames: true,
  contains: true
};

var parseRefsInConditionalKeywords = function parseRefsInConditionalKeywords(schema, context) {
  var recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var pending = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : (0, _immutable.Map)();
  // all schema keywords which are never rendered must be resolved endless-recursive
  // - e.g. `if` is used from within the ConditionalHandler, but it will never be rendered through `PluginStack`
  //   thus any `$ref` can not be resolved at render-flow, but must be resolved beforehand
  // for all schema keywords which may-be rendered, only the first level must be resolved, maybe configurable depth
  // - e.g. if `then` should be applied, this schema is merged into the current one, if it is only a reference
  //   and another `then` is applied and also just a reference, the first reference will be overwritten from the second one and is lost.
  //   when resolving the root ref in the `then`s, those schemas are merged into each other
  var res = {
    schema: schema,
    pending: pending
  };
  Object.keys(checkSchema).forEach(function (keyword) {
    var schemaCond = res.schema.get(keyword);

    if (schemaCond && _immutable.Map.isMap(schemaCond)) {
      var resCheckSchema = parseRefs(schemaCond, context, checkSchema[keyword] || recursive, res.pending);
      res.schema = res.schema.set(keyword, resCheckSchema.schema);
      res.pending = resCheckSchema.pending;
    }
  });
  res = handleResolve(checkConditionalNestedMapSchema, function (schemaMap) {
    return _immutable.Map.isMap(schemaMap);
  }, res.schema, context, true, res.pending);
  res = handleResolve(checkConditionalNestedArraySchema, function (schemaList) {
    return _immutable.List.isList(schemaList);
  }, res.schema, context, recursive, res.pending); // items is either a schema or a list of schemas,
  // here one-schema for all items

  var items = res.schema.get('items');

  if (items && _immutable.Map.isMap(items)) {
    var itemsSchema = parseRefs(items, context, recursive, res.pending);
    res.schema = res.schema.set('items', itemsSchema.schema);
    res.pending = itemsSchema.pending;
  }

  return res;
};

var parseRefs = function parseRefs(schema, context) {
  var recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var pending = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : (0, _immutable.Map)();
  var ref = schema.get('$ref');
  var schemaVersion = schema.get('version');

  if (ref) {
    // 1. if schema is a reference itself, resolve it
    //    then with the next code, references in the reference are resolved
    try {
      var resolved = (0, _resolveRef.resolveRef)(ref, context, schemaVersion); // merging resolved ref with current schema, using mergeDeep, but not with `$ref`
      // - for recursion protection and without `version`, to be sure to get the latest `version`
      // todo: json-schema multi-schema validation

      schema = resolved ? resolved.mergeDeep(schema["delete"]('version')["delete"]('$ref')) : schema;
    } catch (e) {
      if (e instanceof _resolveRef.SchemaRefPending) {
        var id = context.id || '#';
        pending = pending.updateIn([id, ref], function () {
          var refPref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _immutable.List)();
          var v = schema.get('version') || '*';

          if (!refPref.contains(v)) {
            refPref = refPref.push(v);
          }

          return refPref;
        });
      } else {
        throw e;
      }
    }
  }

  if ((0, _SchemaRootProvider.isRootSchema)(schema)) {
    // change context if new root schema
    // enforces this before going deeper when nested/recursive
    context = _objectSpread({}, context);
    context.id = (0, _getSchema.getSchemaId)(schema);
    context.root = schema;
    context.defs = schema.get('definitions') || schema.get('$defs');
  }

  var res = {
    schema: schema,
    pending: pending
  }; // 2. handle conditionals

  res = parseRefsInConditionalKeywords(res.schema, context, recursive, res.pending); // 3. handle validation/applicator schema

  if (recursive) {
    res = parseRefsInRenderingKeywords(res.schema, context, recursive, res.pending);
  }

  return res;
};

exports.parseRefs = parseRefs;