import React from 'react';
import Add from '@material-ui/icons/Add';
import { memo, Trans } from '@ui-schema/ui-schema';
import { ValidityHelperText } from '@ui-schema/ds-material/Component/LocaleHelperText';
import TablePagination from '@material-ui/core/TablePagination';
import MuiTableFooter from '@material-ui/core/TableFooter';
import TableCell from '@material-ui/core/TableCell';
import TableRow from '@material-ui/core/TableRow';
import { TablePaginationActions } from '@ui-schema/ds-material/BaseComponents/Table/TablePaginationActions';
import { withTable } from '@ui-schema/ds-material/BaseComponents/Table/TableContext';
import { Map } from 'immutable';
import { ListButton } from '@ui-schema/ds-material/Component';
export const TableFooterErrorsBase = ({
  colSize = 0,
  showValidity,
  schema,
  valid,
  errors
}) => {
  return !valid && showValidity ? /*#__PURE__*/React.createElement(TableRow, null, /*#__PURE__*/React.createElement(TableCell, {
    colSpan: colSize + 1
  }, /*#__PURE__*/React.createElement(ValidityHelperText
  /*
   * only pass down errors which are not for a specific sub-schema
   * todo: check if all needed are passed down
   */
  , {
    errors: errors,
    showValidity: showValidity,
    schema: schema
  }))) : null;
};
export const TableFooterErrors = withTable(memo(TableFooterErrorsBase));
export const TableFooterBase = ({
  t,
  dense,
  readOnly,
  page,
  setPage,
  setRows,
  listSize,
  listSizeCurrent,
  rows,
  onChange,
  storeKeys,
  schema,
  btnSize,
  btnStyle,
  btnVariant,
  btnColor,
  btnShowLabel,
  colSize,
  showValidity,
  rowsPerPage,
  rowsShowAll,
  noFirstPageButton,
  noLastPageButton
}) => {
  return /*#__PURE__*/React.createElement(MuiTableFooter, null, /*#__PURE__*/React.createElement(TableRow, null, /*#__PURE__*/React.createElement(TableCell, {
    size: dense ? 'small' : 'medium'
  }, !readOnly ? /*#__PURE__*/React.createElement(ListButton, {
    onClick: () => {
      if (rows !== -1) {
        setPage(Number(Math.ceil((listSizeCurrent + 1) / rows)) - 1);
      }

      onChange({
        storeKeys,
        scopes: ['value', 'internal'],
        type: 'list-item-add',
        schema
      });
    },
    btnSize: btnSize,
    btnVariant: btnVariant,
    btnColor: btnColor,
    showLabel: btnShowLabel,
    style: btnStyle,
    Icon: Add,
    title: /*#__PURE__*/React.createElement(Trans, {
      text: 'labels.add-row',
      context: Map({
        actionLabels: schema.get('tableActionLabels')
      })
    })
  }) : null), /*#__PURE__*/React.createElement(TablePagination //rowsPerPageOptions={[5, 10, 25, 50, {label: t('pagination.all') as string, value: -1}]}
  , {
    rowsPerPageOptions: rowsShowAll ? rowsPerPage.push({
      label: t ? t('pagination.all') : 'all',
      value: -1
    }).toArray() : rowsPerPage.toArray(),
    colSpan: colSize + 1,
    count: listSize || 0,
    rowsPerPage: rows,
    page: page,
    SelectProps: {
      inputProps: {
        'aria-label': t ? t('pagination.rows-per-page') : 'per Page'
      } //native: true,

    },
    onPageChange: (_e, p) => setPage(p),
    onRowsPerPageChange: e => {
      setPage(0);
      setRows(Number(e.target.value));
    },
    backIconButtonProps: {
      size: btnSize,
      // using these props as a wrapper - as otherwise not possible to pass down
      noFirstPageButton: noFirstPageButton
    },
    nextIconButtonProps: {
      size: btnSize,
      style: {
        padding: btnSize === 'small' ? 2 : undefined
      },
      // using these props as a wrapper - as otherwise not possible to pass down
      noLastPageButton: noLastPageButton
    },
    ActionsComponent: TablePaginationActions,
    labelRowsPerPage: t ? t('pagination.rows-per-page') + ':' : undefined,
    labelDisplayedRows: ({
      from,
      to,
      count
    }) => "".concat(to !== -1 ? from + '-' + to : count, " ").concat(t ? t('pagination.of') : 'of', " ").concat(count !== -1 ? count : 0)
  })), /*#__PURE__*/React.createElement(TableFooterErrors, {
    colSize: colSize,
    showValidity: showValidity,
    schema: schema
  }));
};
export const TableFooter = memo(TableFooterBase);