import React from 'react';
import { memo, PluginStack, schemaTypeToDistinct } from '@ui-schema/ui-schema';
import { OrderedMap } from 'immutable';
import makeStyles from '@material-ui/core/styles/makeStyles';
import TableCell from '@material-ui/core/TableCell';
import TableRow from '@material-ui/core/TableRow';
import { TableRowActionDelete } from '@ui-schema/ds-material/BaseComponents/Table/TableRowActionDelete';
const useTableRowStyle = makeStyles(theme => ({
  cell: {
    padding: ({
      dense
    }) => dense ? "".concat(theme.spacing(0), "px ").concat(theme.spacing(0.5), "px") : "".concat(theme.spacing(1), "px ").concat(theme.spacing(1.5), "px"),
    overflow: 'hidden'
  },
  groupRenderer: {
    /*padding: ({dense}) =>
        dense ? `${theme.spacing(1)}px ${theme.spacing(0.5)}px` :
            `${theme.spacing(1.5)}px ${theme.spacing(1)}px`,*/
  }
}));
const PluginStackMemo = memo(PluginStack);
export const TableRowRenderer = ({
  parentSchema,
  schema,
  showValidity,
  widgets,
  storeKeys,
  ownKey,
  level,
  uid,
  onChange,
  required,
  dense,
  setPage,
  showRows
}) => {
  var _schema$getIn;

  const classes = useTableRowStyle({
    dense
  }); // only supporting array tuple schemas or objects for table rows / items

  let cellSchema = schema.get('items') || schema.get('properties');
  const readOnly = Boolean(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.get('readOnly'));
  const deleteOnEmpty = (parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.get('deleteOnEmpty')) || required;

  if (schemaTypeToDistinct(schema.get('type')) === 'object' && (_schema$getIn = schema.getIn(['rowSortOrder'])) !== null && _schema$getIn !== void 0 && _schema$getIn.size) {
    let orderedCellSchema = OrderedMap();
    schema.getIn(['rowSortOrder']).forEach(key => {
      orderedCellSchema = orderedCellSchema.set(key, cellSchema.get(key));
    }); // @ts-ignore

    cellSchema = orderedCellSchema;
  }

  const GroupRenderer = widgets.GroupRenderer;
  return /*#__PURE__*/React.createElement(TableRow, null, cellSchema.map((item, j) => item.get('hidden') === true ? /*#__PURE__*/React.createElement(PluginStackMemo, {
    key: j,
    storeKeys: storeKeys.push(j),
    schema: item,
    parentSchema: parentSchema,
    level: level + 1,
    isVirtual: true
  }) : /*#__PURE__*/React.createElement(TableCell, {
    key: j,
    className: classes.cell,
    align: schemaTypeToDistinct(item.get('type')) === 'boolean' ? 'center' : undefined
  }, schemaTypeToDistinct(item.get('type')) === 'object' ? /*#__PURE__*/React.createElement(GroupRenderer, {
    level: 0,
    schema: item,
    className: classes.groupRenderer,
    storeKeys: storeKeys
  }, /*#__PURE__*/React.createElement(PluginStackMemo, {
    showValidity: showValidity,
    storeKeys: storeKeys.push(j),
    schema: item.setIn(['view', 'hideTitle'], true),
    parentSchema: parentSchema,
    level: level + 1,
    readOnly: readOnly // overwriting `widgets`, needs to be passed down further on depending on use cases:
    ,
    widgets: widgets // table field a11y labelling not supported for object,
    // must be done by in-cell translation
    // labelledBy={'uis-' + uid + '-tbl-' + j}

  })) : /*#__PURE__*/React.createElement(PluginStackMemo, {
    showValidity: showValidity,
    storeKeys: storeKeys.push(j),
    schema: item.setIn(['view', 'hideTitle'], true),
    parentSchema: parentSchema,
    level: level + 1,
    readOnly: readOnly,
    noGrid: true // overwriting `widgets`, needs to be passed down further on depending on use cases:
    ,
    widgets: widgets // custom table field prop for a11y labelling
    // todo: `j` is correct for lists, as it mimics the tuple part
    //       for Maps, this must be the property name
    ,
    labelledBy: 'uis-' + uid + '-tbl-' + j
  }))).valueSeq(), !readOnly ? /*#__PURE__*/React.createElement(TableCell, {
    className: classes.cell
  }, /*#__PURE__*/React.createElement(TableRowActionDelete, {
    storeKeys: storeKeys,
    onChange: onChange,
    setPage: setPage,
    index: ownKey,
    deleteOnEmpty: deleteOnEmpty,
    showRows: showRows,
    schema: parentSchema
  })) : null);
};